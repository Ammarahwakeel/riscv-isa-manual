$schema: "normative_rules_schema.json#"

normative_curations:
  - name: mstatus-vs_op
    tags: ["norm:mstatus-vs_sstatus-vs_op", "norm:mstatus-vs_op_initial_clean", "norm:vsstatus-vs_mstatus-vs_op_off", "norm:vsstatus-vs_mstatus-vs_op_active"]

  - name: sstatus-vs_op
    tags: ["norm:mstatus-vs_sstatus-vs_op"]

  - name: mstatus-sd_op
    tags: ["norm:mstatus-sd_op"]

  - name: MUTABLE_MISA_V
    summary: "Implementations may have a writable misa."
    tags: ["norm:MUTABLE_MISA_V"]

  - name: MSTATUS_VS_EXISTS
    summary: "Analogous to the #PARAM way in which the floating-point unit is handled, the mstatus."
    tags: ["norm:MSTATUS_VS_EXISTS"]

  - name: vsstatus-vs_op
    summary: "When the hypervisor extension is present, a vector context status field, VS, is added to vsstatus[10:9]."
    tags: ["norm:vsstatus-vs_op", "norm:vsstatus-vs_mstatus-vs_op_off", "norm:vsstatus-vs_mstatus-vs_op_active"]

  - name: vsstatus-sd_op
    tags: ["norm:vsstatus-sd-vs_op"]

  - name: mstatus-sd_op
    tags: ["norm:mstatus-sd-vs_op"]

  - name: VSSTATUS_VS_EXISTS
    summary: "For implementations with a writable misa."
    tags: ["norm:VSSTATUS_VS_EXISTS"]

  - name: vtype_sz
    tags: ["norm:vtype_sz_acc_op"]

  - name: vtype_acc
    tags: ["norm:vtype_sz_acc_op"]

  - name: vtype_op
    tags: ["norm:vtype_sz_acc_op"]

  - name: vtype-vill_sz
    tags: ["norm:vtype-fields_sz"]

  - name: vtype-vma_sz
    tags: ["norm:vtype-fields_sz"]

  - name: vtype-vta_sz
    tags: ["norm:vtype-fields_sz"]

  - name: vtype-vsew_sz
    tags: ["norm:vtype-fields_sz"]

  - name: vtype-vlmul_sz
    tags: ["norm:vtype-fields_sz"]

  - name: vtype-vsew_op
    summary: "The value in vsew sets the dynamic selected element width (SEW)."
    tags: ["norm:vtype-vsew_op"]

  - name: vtype-vsew_rsv
    summary: "While it is anticipated the larger vsew[2:0] encodings (100-111) will be used to encode larger SEW, the encodings are formally reserved at this point."
    tags: ["norm:vtype-vsew_rsv"]

  - name: vtype-lmul_val
    tags: ["norm:vtype-LMUL_val", "norm:vtype-LMUL_fval"]

  - name: vtype-sew_val
    summary: "For a given supported fractional LMUL setting, implementations must support SEW settings between SEWMIN and LMUL * ELEN, inclusive."
    tags: ["norm:vtype-SEW_val"]

  - name: vtype-lmul_fval_rsv
    summary: "The use of vtype encodings with LMUL < SEWMIN/ELEN is reserved, but implementations can set vill if they do not support these configurations."
    tags: ["norm:vtype-LMUL_fval_rsv"]

  - name: LMUL
    summary: "LMUL is set by the signed vlmul field in vtype (i."
    tags: ["norm:LMUL"]

  - name: VLMAX
    summary: "The derived value VLMAX = LMUL*VLEN/SEW represents the maximum number of elements that can be operated on with a single vector instruction given the current SEW and LMUL settings as shown in the table"
    tags: ["norm:VLMAX"]

  - name: vreg_offgroup_LMUL2_rsv
    summary: "Instructions specifying an LMUL=2 vector register group with an odd-numbered vector register are reserved."
    tags: ["norm:vreg_offgroup_LMUL2_rsv"]

  - name: vreg_offgroup_LMUL4_rsv
    summary: "instructions specifying an LMUL=4 vector register group using vector register numbers that are not multiples of four are reserved."
    tags: ["norm:vreg_offgroup_LMUL4_rsv"]

  - name: vreg_offgroup_LMUL8_rsv
    summary: "instructions specifying an LMUL=8 vector register group using register numbers that are not multiples of eight are reserved."
    tags: ["norm:vreg_offgroup_LMUL8_rsv"]

  - name: vreg_mask_LMUL_indp
    summary: "Mask registers are always contained in a single vector register, regardless of LMUL."
    tags: ["norm:vreg_mask_LMUL_indp"]

  - name: vtype-vta_op
    summary: "These two bits modify the behavior of destination tail elements and destination inactive masked-off elements respectively during the execution of vector instructions."
    tags: ["norm:vtype-vta-vma_op"]

  - name: vtype-vma_op
    summary: "These two bits modify the behavior of destination tail elements and destination inactive masked-off elements respectively during the execution of vector instructions."
    tags: ["norm:vtype-vta-vma_op"]
  
  - name: vtype-vta_val
    tags: ["norm:vtype-vta-vma_val"]

  - name: vtype-vma_val
    tags: ["norm:vtype-vta-vma_val"]

  - name: vreg_mask_tail_agn
    summary: "Mask destination tail elements are always treated as tail-agnostic, regardless of the setting of vta."
    tags: ["norm:vreg_mask_tail_agn"]

  - name: vreg_mask_op
    summary: "When a set is marked undisturbed, the corresponding set of destination elements in a vector register group retain the value they previously held."
    tags: ["norm:vreg_mask_op"]

  - name: vreg_agnostic_op
    summary: "When a set is marked agnostic, the corresponding set of destination elements in any vector destination operand can either retain the value they previously held, or are overwritten with 1s."
    tags: ["norm:vreg_agnostic_op"]

  - name: vreg_mask_tail_op
    summary: "In addition, except for mask load instructions, any element in the tail of a mask result can also be written with the value the mask-producing operation would have calculated with vl=VLMAX."
    tags: ["norm:vreg_mask_tail_op"]

  - name: vtype-vill_op
    summary: "If the vill bit is set, then any attempt to execute a vector instruction that depends upon vtype will raise an illegal-instruction exception."
    tags: ["norm:vtype-vill_op"]

  - name: vl_acc
    summary: "The XLEN-bit-wide read-only vl CSR can only be updated by the vset{i}vl{i} instructions, and the fault-only-first vector load instruction variants."
    tags: ["norm:vl_acc"]

  - name: vl_op
    summary: "The vl register holds an unsigned integer specifying the number of elements to be updated with results from a vector instruction, as further detailed in ."
    tags: ["norm:vl_op"]
  
  - name: vlenb_op
    summary: "The XLEN-bit-wide read-only CSR vlenb holds the value VLEN/8, i."
    tags: ["norm:vlenb_acc_op"]

  - name: vlenb_acc
    summary: "The XLEN-bit-wide read-only CSR vlenb holds the value VLEN/8, i."
    tags: ["norm:vlenb_acc_op"]
  
  - name: vstart_sz
    summary: "The XLEN-bit-wide read-write vstart CSR specifies the index of the first element to be executed by a vector instruction, as described in ."
    tags: ["norm:vstart_acc_sz"]

  - name: vstart_acc
    summary: "The XLEN-bit-wide read-write vstart CSR specifies the index of the first element to be executed by a vector instruction, as described in ."
    tags: ["norm:vstart_acc_sz"]

  - name: vstart_op
    summary: "All vector instructions are defined to begin execution with the element number given in the vstart CSR, leaving earlier elements in the destination vector undisturbed"
    tags: ["norm:vstart_op"]

  - name: vstart_update
    summary: "reset the vstart CSR to zero at the end of execution."
    tags: ["norm:vstart_update"]

  - name: vstart_unmodified
    summary: "vstart is not modified by vector instructions that raise illegal-instruction exceptions."
    tags: ["norm:vstart_unmodified"]

  - name: vstart_sz_writable
    summary: "The vstart CSR is defined to have only enough writable bits to hold the largest element index (one less than the maximum VLMAX)."
    tags: ["norm:vstart_sz_writable"]

  - name: vstart_val_rsv
    summary: "The use of vstart values greater than the largest element index for the current vtype setting is reserved."
    tags: ["norm:vstart_val_rsv"]

  - name: vstart_vtype_dep
    summary: "Implementations are permitted to raise illegal-instruction exceptions when attempting to execute a vector instruction with a value of vstart that the implementation can never produce when executing th"
    tags: ["norm:vstart_vtype_dep"]
  
  - name: vxrm_acc
    summary: "The vector fixed-point rounding-mode register holds a two-bit read-write rounding-mode field in the least-significant bits (vxrm[1:0])."
    tags: ["norm:vxrm_val_sz_acc"]

  - name: vxrm_sz
    summary: "The vector fixed-point rounding-mode register holds a two-bit read-write rounding-mode field in the least-significant bits (vxrm[1:0])."
    tags: ["norm:vxrm_val_sz_acc"]

  - name: vxrm_val
    summary: "The vector fixed-point rounding-mode register holds a two-bit read-write rounding-mode field in the least-significant bits (vxrm[1:0])."
    tags: ["norm:vxrm_val_sz_acc"]

  - name: vcsr-vxrm
    summary: "The vector fixed-point rounding-mode is given a separate CSR address to allow independent access, but is also reflected as a field in vcsr."
    tags: ["norm:vcsr-vxrm"]

  - name: vxrm_op
    summary: "The fixed-point rounding algorithm is specified as follows."
    tags: ["norm:vxrm_op"]
  
  - name: vxsat_op
    summary: "The vxsat CSR has a single read-write least-significant bit (vxsat[0])that indicates if a fixed-point instruction has had to saturate an output value to fit into a destination format."
    tags: ["norm:vxsat_op_acc_sz"]

  - name: vxsat_acc
    summary: "The vxsat CSR has a single read-write least-significant bit (vxsat[0])that indicates if a fixed-point instruction has had to saturate an output value to fit into a destination format."
    tags: ["norm:vxsat_op_acc_sz"]

  - name: vxsat_sz
    summary: "The vxsat CSR has a single read-write least-significant bit (vxsat[0])that indicates if a fixed-point instruction has had to saturate an output value to fit into a destination format."
    tags: ["norm:vxsat_op_acc_sz"]

  - name: vcsr-vxsat
    summary: "The vxsat bit is mirrored in vcsr."
    tags: ["norm:vcsr-vxsat"]

  - name: vcsr_val
    summary: "The vxrm and vxsat separate CSRs can also be accessed via fields in the XLEN-bit-wide vector control and status CSR, vcsr."
    tags: ["norm:vcsr_val"]

  - name: vreg_lmul1_op
    summary: "When LMUL=1, elements are simply packed in order from the least-significant to most-significant bits of the vector register."
    tags: ["norm:vreg_LMUL1_op"]

  - name: vreg_flmul_op
    summary: "When LMUL < 1, only the first LMUL*VLEN/SEW elements in the vector register are used."
    tags: ["norm:vreg_fLMUL_op"]

  - name: vreg_lmulge2_op
    summary: "When vector registers are grouped, the elements of the vector register group are packed contiguously in element order beginning with the lowest-numbered vector register and moving to the next-highest-"
    tags: ["norm:vreg_LMULge2_op"]

  - name: vreg_mask_vtype_indp
    summary: "A vector mask occupies only one vector register regardless of SEW and LMUL."
    tags: ["norm:vreg_mask_vtype_indp"]

  - name: vreg_mask_sz
    summary: "Each element is allocated a single mask bit in a mask vector register."
    tags: ["norm:vreg_mask_sz"]

  - name: vreg_scalar_lmul_indp
    summary: "Any vector register can be used to hold a scalar regardless of the current LMUL setting."
    tags: ["norm:vreg_scalar_LMUL_indp"]

  - name: EEW
    summary: "Each vector operand has an effective element width (EEW) and an effective LMUL (EMUL) that is used to determine the size and location of all the elements within a vector register group."
    tags: ["norm:EEW_EMUL"]

  - name: EMUL
    summary: "Each vector operand has an effective element width (EEW) and an effective LMUL (EMUL) that is used to determine the size and location of all the elements within a vector register group."
    tags: ["norm:EEW_EMUL"]

  - name: EMUL_SEW_LMUL_dep
    summary: "EEW/EMUL = SEW/LMUL."
    tags: ["norm:EEW_EMUL_SEW_LMUL_dep"]
  
  - name: EEW_SEW_LMUL_dep
    summary: "EEW/EMUL = SEW/LMUL."
    tags: ["norm:EEW_EMUL_SEW_LMUL_dep"]

  - name: vnarrowing_EEW
    summary: "Narrowing instructions have a source operand that has EEW=2*SEW and EMUL=2*LMUL but with a destination where EEW=SEW and EMUL=LMUL."
    tags: ["norm:vnarrowing_EEW_EMUL"]

  - name: vnarrowing_EMUL
    summary: "Narrowing instructions have a source operand that has EEW=2*SEW and EMUL=2*LMUL but with a destination where EEW=SEW and EMUL=LMUL."
    tags: ["norm:vnarrowing_EEW_EMUL"]

  - name: EMUL_offgroup_rsv
    summary: "Using other than the lowest-numbered vector register to specify a vector register group is a reserved encoding."
    tags: ["norm:EMUL_offgroup_rsv"]

  - name: vreg_source_EEW_rsv
    summary: "A vector register cannot be used to provide source operands with more than one EEW for a single instruction."
    tags: ["norm:vreg_source_EEW_rsv"]

  - name: vreg_overlap_legal
    summary: "See list: [ \"#<Asciidoctor::ListItem@83680 {list_context: :ulist, text: \\"The destination EEW equals the source EEW.\\", blocks: 0}>\", \"#<Asciidoctor::ListItem@83700 {list"
    tags: ["norm:vreg_overlap_legal"]

  - name: vreg_mask_overlap
    summary: "For the purpose of determining register group overlap constraints, mask elements have EEW=1."
    tags: ["norm:vreg_mask_overlap"]

  - name: vreg_overlap_rsv
    summary: "Any instruction encoding that violates the overlap constraints is reserved."
    tags: ["norm:vreg_overlap_rsv"]

  - name: vreg_overlap_agn
    summary: "When source and destination registers overlap and have different EEW, the instruction is mask- and tail-agnostic, regardless of the setting of the vta and vma bits in vtype."
    tags: ["norm:vreg_overlap_agn"]

  - name: EMUL_rsv
    summary: "The largest vector register group used by an instruction can not be greater than 8 vector registers (i."
    tags: ["norm:EMUL_rsv"]

  - name: vreg_scalar_EMUL
    summary: "Widened scalar values, e."
    tags: ["norm:vreg_scalar_EMUL"]

  - name: vmask_op
    tags: ["norm:vmask_inactive_op", "norm:vmask_agn_op", "norm:vmask_vm_op"]
    
  - name: vreg_vmask
    summary: "The mask value used to control execution of a masked vector instruction is always supplied by vector register v0."
    tags: ["norm:vreg_vmask"]

  - name: vreg_vmask_rsv
    summary: "The destination vector register group for a masked vector instruction cannot overlap the source mask register (v0), unless the destination vector register is being written with a mask value (e."
    tags: ["norm:vreg_vmask_rsv"]

  - name: vstart_vl_dep
    summary: "When vstart ≥ vl, there are no body elements, and no elements are updated in any destination vector register group, including that no tail elements are updated with agnostic values."
    tags: ["norm:vstart_vl_dep"]

  - name: vstart_vl_scalar_indp
    summary: "Instructions that write an x register or f register do so even when vstart ≥ vl, including when vl=0."
    tags: ["norm:vstart_vl_scalar_indp"]

  - name: vtype_acc
    summary: "The new vtype value is encoded in the immediate fields of vsetvli and vsetivli, and in the rs2 register for vsetvl."
    tags: ["norm:vtype_acc"]
    
  - name: vtype-vill_set
    summary: "If the vtype value is not supported by the implementation, then the vill bit is set in vtype, the remaining bits in vtype are set to zero, and the vl register is also set to zero."
    tags: ["norm:vtype-vill_val", "norm:vtype-vill_val_vill", "norm:vtype-vill_all_bits"]
 
  - name: vsetvl_op
    summary: "When rs1 is not x0, the AVL is an unsigned integer held in the x register specified by rs1, and the new vl value is also written to the x register specified by rd."
    tags: ["norm:vsetvl_op", "norm:vsetvl_op_rs1_x0_rd_nx0"]

  - name: vsetivli_op
    summary: "For the vsetivli instruction, the AVL is encoded as a 5-bit zero-extended immediate (0–31) in the rs1 field."
    tags: ["norm:vsetivli_op"]

  - name: vl_val
    tags: ["norm:vl_val"]

  - name: VECTOR_LS_VSTART
    summary: "All vector loads and stores may generate and accept a non-zero vstart value."
    tags: ["norm:VECTOR_LS_VSTART"]

  - name: vector_ls_base_stride_regtype
    summary: "Vector load/store base registers and strides are taken from the GPR x registers."
    tags: ["norm:vector_ls_base_stride_regtype"]

  - name: vector_ls_base
    summary: "The base effective address for all vector accesses is given by the contents of the x register named in rs1."
    tags: ["norm:vector_ls_base"]

  - name: vector_ls_unit-stride_op
    summary: "Vector unit-stride operations access elements stored contiguously in memory starting from the base effective address."
    tags: ["norm:vector_ls_unit-stride_op"]

  - name: vector_ls_constant-stride_op
    summary: "Vector constant-stride operations access the first memory element at the base effective address, and then access subsequent elements at address increments given by the byte offset contained in the x r"
    tags: ["norm:vector_ls_constant-stride_op"]

  - name: vector_ls_indexed_op
    summary: "Vector indexed operations add the contents of each element of the vector offset operand specified by vs2 to the base effective address to give the effective address of each element."
    tags: ["norm:vector_ls_indexed_op"]

  - name: vector_ls_bytewise
    summary: "The vector offset operand is treated as a vector of byte-address offsets."
    tags: ["norm:vector_ls_bytewise"]

  - name: vector_ls_XLEN_dep
    summary: "If the vector offset elements are narrower than XLEN, they are zero-extended to XLEN before adding to the base effective address."
    tags: ["norm:vector_ls_XLEN_dep"]

  - name: vector_ls_EEW_rsv
    summary: "If the implementation does not support the EEW of the offset elements, the instruction is reserved."
    tags: ["norm:vector_ls_EEW_rsv"]

  - name: vector_ls_stride_ordered_op
    summary: "Vector unit-stride and constant-stride memory accesses do not guarantee ordering between individual element accesses."
    tags: ["norm:vector_ls_stride_ordered_op"]

  - name: vector_ls_stride_unordered_op
    summary: "For unordered instructions (mop[1:0]!=11) there is no guarantee on element access order."
    tags: ["norm:vector_ls_stride_unordered_op"]

  - name: vector_ls_stride_unordered_precise
    summary: "For implementations with precise vector traps, exceptions on indexed-unordered stores must also be precise."
    tags: ["norm:vector_ls_stride_unordered_precise"]

  - name: vector_ls_nf_op
    summary: "The nf[2:0] field encodes the number of fields in each segment."
    tags: ["norm:vector_ls_nf_op"]

  - name: vector_wholels_nf_op
    summary: "The nf[2:0] field also encodes the number of whole vector registers to transfer for the whole vector register load/store instructions."
    tags: ["norm:vector_wholels_nf_op"]

  - name: vector_ls_EEW
    summary: "Vector loads and stores have an EEW encoded directly in the instruction."
    tags: ["norm:vector_ls_EEW_EMUL"]

  - name: vector_ls_EMUL
    summary: "Vector loads and stores have an EEW encoded directly in the instruction."
    tags: ["norm:vector_ls_EEW_EMUL"]

  - name: vector_ls_EMUL_rsv
    summary: "If the EMUL would be out of range (EMUL>8 or EMUL<1/8), the instruction encoding is reserved."
    tags: ["norm:vector_ls_EMUL_rsv"]

  - name: vector_ls_EMUL_offgroup_rsv
    summary: "The vector register groups must have legal register specifiers for the selected EMUL, otherwise the instruction encoding is reserved."
    tags: ["norm:vector_ls_EMUL_offgroup_rsv"]

  - name: vector_ls_indexed_EEW
    summary: "Vector unit-stride and constant-stride use the EEW/EMUL encoded in the instruction for the data values, while vector indexed loads and stores use the EEW/EMUL encoded in the instruction for the index "
    tags: ["norm:vector_ls_indexed_EEW_EMUL"]

  - name: vector_ls_indexed_EMUL
    summary: "Vector unit-stride and constant-stride use the EEW/EMUL encoded in the instruction for the data values, while vector indexed loads and stores use the EEW/EMUL encoded in the instruction for the index "
    tags: ["norm:vector_ls_indexed_EEW_EMUL"]

  - name: vector_ls_ins_rsv
    summary: "Vector load/store encodings for unsupported EEW widths are reserved."
    tags: ["norm:vector_ls_ins_rsv"]

  - name: vector_ls_mew_rsv
    summary: "The mew bit (inst[28]) when set is expected to be used to encode expanded memory sizes of 128 bits and above, but these encodings are currently reserved."
    tags: ["norm:vector_ls_mew_rsv"]

  - name: vector_ls_unit-stride_mask
    summary: "Additional unit-stride mask load and store instructions are provided to transfer mask values to/from memory."
    tags: ["norm:vector_ls_unit-stride_mask"]

  - name: vector_ls_neg_stride
    summary: "Negative and zero strides are supported."
    tags: ["norm:vector_ls_neg_zero_stride"]

  - name: vector_ls_zero_stride
    summary: "Negative and zero strides are supported."
    tags: ["norm:vector_ls_neg_zero_stride"]

  - name: vector_ls_constant-stride_unordered
    summary: "Element accesses within a constant-stride instruction are unordered with respect to each other."
    tags: ["norm:vector_ls_constant-stride_unordered"]

  - name: VECTOR_LS_CONSTANT_STRIDE_x0_OPT
    summary: "When rs2=x0, then an implementation is allowed, but not required, to perform fewer memory operations than the number of active elements, and may perform different numbers of memory operations across d"
    tags: ["norm:VECTOR_LS_CONSTANT_STRIDE_x0_OPT"]

  - name: vector_ff_trigger
    tags: ["norm:vector_ff_trigger"]

  - name: VECTOR_LS_OVERWRITE_PAST_TRAP
    summary: "Load instructions may overwrite active destination vector register group elements past the element index at which the trap is reported."
    tags: ["norm:VECTOR_LS_OVERWRITE_PAST_TRAP"]

  - name: VECTOR_FF_PAST_TRAP
    summary: "Similarly, fault-only-first load instructions may update active destination elements past the element that causes trimming of the vector length (but not past the original vector length)."
    tags: ["norm:VECTOR_FF_PAST_TRAP"]

  - name: vector_ff_no_exception
    summary: "Even when an exception is not raised, implementations are permitted to process fewer than vl elements and reduce vl accordingly, but if vstart=0 and vl>0, then at least one element must be processed."
    tags: ["norm:vector_ff_no_exception"]

  - name: vector_ff_interrupt_behavior
    summary: "When the fault-only-first instruction takes a trap due to an interrupt, implementations should not reduce vl and should instead set a vstart value."
    tags: ["norm:vector_ff_interrupt_behavior"]

  - name: NFIELDS
    summary: "The three-bit nf field in the vector instruction encoding is an unsigned integer that contains one less than the number of fields per segment, NFIELDS."
    tags: ["norm:NFIELDS", "norm:NFIELDS_op"]

  - name: EMUL_NFIELDS_rsv
    summary: "The EMUL setting must be such that EMUL * NFIELDS ≤ 8, otherwise the instruction encoding is reserved."
    tags: ["norm:EMUL_NFIELDS_rsv"]

  - name: vector_ls_seg_rsv
    summary: "If the vector register numbers accessed by the segment load or store would increment past 31, then the instruction encoding is reserved."
    tags: ["norm:vector_ls_seg_rsv"]

  - name: vector_ls_seg_op
    summary: "The vl register gives the number of segments to move, which is equal to the number of elements transferred to each vector register group."
    tags: ["norm:vector_ls_seg_op"]

  - name: vector_ls_seg_unordered
    summary: "For segment loads and stores, the individual memory accesses used to access fields within each segment are unordered with respect to each other even for ordered indexed segment loads and stores."
    tags: ["norm:vector_ls_seg_unordered"]

  - name: vector_ls_seg_vstart_dep
    summary: "The vstart value is in units of whole segments."
    tags: ["norm:vector_ls_seg_vstart_dep"]

  - name: VECTOR_LS_SEG_PARTIAL_ACCESS
    summary: "If a trap occurs during access to a segment, it is implementation-defined whether a subset of the faulting segment's accesses are performed before the trap is taken."
    tags: ["norm:VECTOR_LS_SEG_PARTIAL_ACCESS"]

  - name: vector_ls_seg_unit-stride_op
    summary: "The vector unit-stride load and store segment instructions move packed contiguous segments into multiple destination vector register groups."
    tags: ["norm:vector_ls_seg_unit-stride_op"]

  - name: vector_ls_seg_ff_unit-stride_op
    summary: "For fault-only-first segment loads, if an exception is detected partway through accessing the zeroth segment, the trap is taken."
    tags: ["norm:vector_ls__seg_ff_unit-stride_op"]

  - name: VECTOR_FF_SEG_PARTIAL_ACCESS
    summary: "In both cases, it is implementation-defined whether a subset of the segment is loaded."
    tags: ["norm:VECTOR_FF_SEG_PARTIAL_ACCESS"]

  - name: vector_ls_seg_ff_overload
    summary: "These instructions may overwrite destination vector register group elements past the point at which a trap is reported or past the point at which vector length is trimmed."
    tags: ["norm:VECTOR_LS_SEG_FF_OVERLOAD"]

  - name: vector_ls_seg_constant-stride_op
    summary: "Vector constant-stride segment loads and stores move contiguous segments where each segment is separated by the byte-stride offset given in the rs2 GPR argument."
    tags: ["norm:vector_ls_seg_constant-stride_op"]

  - name: vector_ls_seg_constant-stride_unordered
    summary: "Accesses to the fields within each segment can occur in any order, including the case where the byte stride is such that segments overlap in memory."
    tags: ["norm:vector_ls_seg_constant-stride_unordered"]

  - name: vector_ls_seg_indexed_op
    summary: "Vector indexed segment loads and stores move contiguous segments where each segment is located at an address given by adding the scalar base address in the rs1 field to byte offsets in vector register"
    tags: ["norm:vector_ls_seg_indexed_op"]

  - name: vector_ls_seg_indexed_EMUL_op
    summary: "The data vector register group has EEW=SEW, EMUL=LMUL, while the index vector register group has EEW encoded in the instruction with EMUL=(EEW/SEW)*LMUL."
    tags: ["norm:vector_ls_seg_indexed_EEW_EMUL_op"]

  - name: vector_ls_seg_indexed_EEW_op
    summary: "The data vector register group has EEW=SEW, EMUL=LMUL, while the index vector register group has EEW encoded in the instruction with EMUL=(EEW/SEW)*LMUL."
    tags: ["norm:vector_ls_seg_indexed_EEW_EMUL_op"]
  
  - name: vector_ls_seg_indexed_NFIELDS_val
    summary: "The EMUL * NFIELDS ≤ 8 constraint applies to the data vector register group."
    tags: ["norm:vector_ls_seg_indexed_EMUL_NFIELDS_val"]

  - name: vector_ls_seg_indexed_EMUL_val
    summary: "The EMUL * NFIELDS ≤ 8 constraint applies to the data vector register group."
    tags: ["norm:vector_ls_seg_indexed_EMUL_NFIELDS_val"]

  - name: vector_ls_seg_indexed_vreg_rsv
    summary: "For vector indexed segment loads, the destination vector register groups cannot overlap the source vector register group (specified by vs2), else the instruction encoding is reserved."
    tags: ["norm:vector_ls_seg_indexed_vreg_rsv"]

  - name: vector_ls_seg_wholereg_EEW
    summary: "The load instructions have an EEW encoded in the mew and width fields following the pattern of regular unit-stride loads."
    tags: ["norm:vector_ls_seg_wholereg_EEW"]

  - name: vector_ls_seg_wholereg_op
    summary: "NFIELDS indicates the number of vector registers to transfer, numbered successively after the base."
    tags: ["norm:vector_ls_seg_wholereg_op"]

  - name: vector_ls_seg_wholereg_nf_rsv
    summary: "Only NFIELDS values of 1, 2, 4, 8 are supported, with other values reserved."
    tags: ["norm:vector_ls_seg_wholereg_nf_rsv"]

  - name: vector_ls_seg_wholereg_op_cont
    summary: "When multiple registers are transferred, the lowest-numbered vector register is held in the lowest-numbered memory addresses and successive vector register numbers are placed contiguously in memory."
    tags: ["norm:vector_ls_seg_wholereg_op_cont"]

  - name: vector_ls_seg_wholereg_evl
    summary: "The instructions operate with an effective vector length, evl=NFIELDS*VLEN/EEW, regardless of current settings in vtype and vl."
    tags: ["norm:vector_ls_seg_wholereg_evl"]

  - name: VECTOR_LS_WHOLEREG_MISSALIGNED_EXCEPTION
    summary: "Implementations are allowed to raise a misaligned address exception on whole register loads and stores if the base address is not naturally aligned to the larger of the size of the encoded EEW in byte"
    tags: ["norm:VECTOR_LS_WHOLEREG_MISSALIGNED_EXCEPTION"]

  - name: VECTOR_LS_MISSALIGNED_EXCEPTION
    summary: "If an element accessed by a vector memory instruction is not naturally aligned to the size of the element, either the element is transferred successfully or an address-misaligned exception is raised o"
    tags: ["norm:VECTOR_LS_MISSALIGNED_EXCEPTION"]

  - name: vector_ls_program_order
    summary: "Vector memory instructions appear to execute in program order on the local hart."
    tags: ["norm:vector_ls_program_order"]

  - name: vector_ls_RVMO
    summary: "Vector memory instructions follow RVWMO at the instruction level."
    tags: ["norm:vector_ls_RVMO"]

  - name: vector_ls_indexed_ordered_ordered
    summary: "Except for vector indexed-ordered loads and stores, element operations are unordered within the instruction."
    tags: ["norm:vector_ls_indexed-ordered_ordered"]

  - name: vector_ls_indexed_ordered_RVWMO
    summary: "Vector indexed-ordered loads and stores read and write elements from/to memory in element order respectively, obeying RVWMO at the element level."
    tags: ["norm:vector_ls_indexed-ordered_RVWMO"]

  - name: vl_control_dependency
    summary: "Instructions affected by the vector length register vl have a control dependency on vl, rather than a data dependency."
    tags: ["norm:vl_control_dependency"]

  - name: vmask_control_dependency
    summary: "Similarly, masked vector instructions have a control dependency on the source mask register, rather than a data dependency."
    tags: ["norm:vmask_control_dependency"]
